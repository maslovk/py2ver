// -----------------------------------------------------------------------------
// uart_transceiver.v  (LOOPBACK-capable, single-writer FIFO â€” no multi-drivers)
//  - 50 MHz default, 115200 baud
//  - RX: 16x oversampling (mid-bit sampling with optional majority-of-3)
//  - Normal: packs tx_data -> UART; RX assembles bytes -> rx_data (pulses rx_valid)
//  - LOOPBACK=1: ignore tx_data/tx_valid; echo each received byte
//  - baud_tick is phase-aligned to oversample_tick (derived from it)
// -----------------------------------------------------------------------------
module uart_transceiver #(
    parameter integer CLK_HZ          = 50000000,
    parameter integer BAUD            = 115200,
    parameter integer TX_WIDTH        = 32,
    parameter integer RX_WIDTH        = 32,
    parameter bit     LOOPBACK        = 1'b1,
    parameter integer OSR             = 16,   // oversample rate (logic assumes 16)
    parameter bit     RX_ENA_STOPCHK  = 1'b1, // gate output on a good stop bit
    parameter bit     RX_MAJ3         = 1'b1  // 3-sample majority around mid-bit
)(
    input  wire                     clk,
    input  wire                     rst_n,

    // Parallel transmit (ignored when LOOPBACK=1)
    input  wire [TX_WIDTH-1:0]      tx_data,
    input  wire                     tx_valid,   // 1-clk strobe to start sending tx_data
    output wire                     tx_busy,

    // UART pins
    output wire                     tx,
    input  wire                     rx,

    // Parallel receive
    output reg  [RX_WIDTH-1:0]      rx_data,
    output reg                      rx_valid,

    // Status (optional)
    output reg                      rx_ferr,      // framing error (bad stop) pulse
    output reg                      lb_overflow   // loopback FIFO overflow latched
);
    // Enforce OSR=16 for this implementation
    localparam _ASSERT_OSR_16 = (OSR == 16) ? 1 : -1;
    // synthesis translate_off
    initial if (OSR != 16) $error("uart_transceiver: OSR must be 16 in this variant.");
    // synthesis translate_on

    // =========================================================================
    // Baud / Oversample
    // =========================================================================
    localparam integer DIV_OS_TICK  = (CLK_HZ + (BAUD*OSR)/2) / (BAUD*OSR);

    // 16x oversample tick
    reg [$clog2(DIV_OS_TICK)-1:0] os_div = 0;
    reg os_tick;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin os_div <= 0; os_tick <= 1'b0; end
        else begin
            os_tick <= 1'b0;
            if (os_div == DIV_OS_TICK-1) begin os_div <= 0; os_tick <= 1'b1; end
            else os_div <= os_div + 1'b1;
        end
    end

    // 1x baud tick derived from oversample tick (phase-aligned)
    reg [3:0] osr_cnt = 0;  // 0..15
    reg       baud_tick;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin osr_cnt <= 0; baud_tick <= 1'b0; end
        else begin
            baud_tick <= 1'b0;
            if (os_tick) begin
                if (osr_cnt == OSR-1) begin
                    osr_cnt  <= 0;
                    baud_tick<= 1'b1;
                end else begin
                    osr_cnt <= osr_cnt + 4'd1;
                end
            end
        end
    end

    // =========================================================================
    // UART RX (8N1, 16x oversampling with (optional) majority-of-3 mid-bit)
    // =========================================================================
    reg rx_s1, rx_s2;
    always @(posedge clk) begin
        rx_s1 <= rx;
        rx_s2 <= rx_s1; // double-sync
    end

    reg [3:0]  rx_os_cnt;     // 0..15 within bit
    reg [7:0]  rx_total_os;   // 0..159 over frame (10 bits * 16)
    reg [2:0]  rx_bit_idx;    // data bits 0..7
    reg [7:0]  rx_shift;
    reg        rx_busy_b;
    reg        rx_byte_ready;
    reg [7:0]  rx_byte;
    reg        rx_stop_ok;    // simple stop-bit check (optional)

    // Majority-of-3 sampler around mid-bit (samples at 6,7,8)
    reg [1:0]  maj_accum;     // holds sum of 3 samples (0..3)
    wire       maj_bit = (maj_accum >= 2);

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_os_cnt     <= 0;
            rx_total_os   <= 0;
            rx_bit_idx    <= 0;
            rx_shift      <= 8'h00;
            rx_busy_b     <= 1'b0;
            rx_byte_ready <= 1'b0;
            rx_byte       <= 8'h00;
            rx_stop_ok    <= 1'b0;
            rx_ferr       <= 1'b0;
            maj_accum     <= 0;
        end else begin
            rx_byte_ready <= 1'b0;
            rx_ferr       <= 1'b0;

            if (!rx_busy_b) begin
                // detect start (low) on an oversample edge; arm the frame
                if (os_tick && (rx_s2 == 1'b0)) begin
                    rx_busy_b   <= 1'b1;
                    rx_os_cnt   <= 4'd0;
                    rx_total_os <= 8'd0;
                    rx_bit_idx  <= 3'd0;
                    rx_shift    <= 8'h00;
                    rx_stop_ok  <= 1'b0;
                    maj_accum   <= 0;
                end
            end else if (os_tick) begin
                // advance oversample counters
                rx_os_cnt   <= rx_os_cnt + 4'd1;     // wraps naturally 15->0
                rx_total_os <= rx_total_os + 8'd1;

                // Majority-of-3 around mid-bit (ticks 6,7,8 of each bit cell)
                if (RX_MAJ3) begin
                    if (rx_os_cnt == 4'd6)      maj_accum <= {1'b0, rx_s2};           // = rx_s2
                    else if (rx_os_cnt == 4'd7) maj_accum <= maj_accum + {1'b0, rx_s2};
                    else if (rx_os_cnt == 4'd8) maj_accum <= maj_accum + {1'b0, rx_s2};
                end

                // sampling events
                if (!RX_MAJ3) begin
                    // single mid-bit sample points: 7, 23, ..., 7 + n*16
                    if (rx_os_cnt == 4'd7) begin
                        if (rx_total_os >= 8'd16 && rx_total_os < 8'd144) begin
                            rx_shift[rx_bit_idx] <= rx_s2; // LSB-first
                            rx_bit_idx           <= rx_bit_idx + 3'd1;
                        end else if (rx_total_os == 8'd151) begin
                            rx_stop_ok <= rx_s2; // expect high
                        end
                    end
                end else begin
                    // majority sample is latched on tick 8 (after collecting 6,7,8)
                    if (rx_os_cnt == 4'd8) begin
                        if (rx_total_os >= 8'd17 && rx_total_os < 8'd145) begin
                            rx_shift[rx_bit_idx] <= maj_bit; // LSB-first
                            rx_bit_idx           <= rx_bit_idx + 3'd1;
                        end else if (rx_total_os == 8'd152) begin
                            rx_stop_ok <= maj_bit; // expect high
                        end
                    end
                end

                // end of 10-bit frame (start + 8 data + stop)
                if (rx_total_os == (OSR*10 - 1)) begin
                    rx_busy_b     <= 1'b0;
                    if (!RX_ENA_STOPCHK || rx_stop_ok) begin
                        rx_byte       <= rx_shift;
                        rx_byte_ready <= 1'b1;
                    end else begin
                        rx_ferr       <= 1'b1; // bad stop bit
                    end
                end
            end
        end
    end

    // =========================================================================
    // Tiny 4-byte FIFO for LOOPBACK (single writer block!)
    // =========================================================================
    reg [7:0] lb_mem [0:3];
    reg [1:0] lb_rptr, lb_wptr;
    reg [2:0] lb_count; // 0..4

    wire lb_full  = (lb_count == 3'd4);
    wire lb_empty = (lb_count == 3'd0);
    wire [7:0] lb_dout = lb_mem[lb_rptr];

    // Pop pulse (generated by TX state machine)
    reg  lb_pop_pulse;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            lb_rptr <= 2'd0; lb_wptr <= 2'd0; lb_count <= 3'd0;
            lb_overflow <= 1'b0;
        end else if (LOOPBACK) begin
            // push from RX
            if (rx_byte_ready) begin
                if (!lb_full) begin
                    lb_mem[lb_wptr] <= rx_byte;
                    lb_wptr <= lb_wptr + 2'd1;
                end else begin
                    lb_overflow <= 1'b1; // sticky; clear externally if you add a CSR
                end
            end
            // pop from TX
            if (lb_pop_pulse && !lb_empty) begin
                lb_rptr <= lb_rptr + 2'd1;
            end
            // count update (push/pop same cycle allowed)
            case ({(rx_byte_ready && !lb_full), (lb_pop_pulse && !lb_empty)})
                2'b10: lb_count <= lb_count + 3'd1;
                2'b01: lb_count <= lb_count - 3'd1;
                default: /* no change */ ;
            endcase
        end else begin
            // keep reset when not used
            lb_rptr <= 2'd0; lb_wptr <= 2'd0; lb_count <= 3'd0;
            lb_overflow <= 1'b0;
        end
    end

    // =========================================================================
    // UART TX (8N1)
    // =========================================================================
    reg [9:0] tx_shift;
    reg [3:0] tx_bit_cnt;      // 0..9
    reg       tx_busy_b;

    assign tx      = tx_shift[0];
    assign tx_busy = tx_busy_b;

    localparam integer TX_BYTES = (TX_WIDTH + 7) / 8;
    reg [$clog2(TX_BYTES):0] tx_byte_idx;
    wire [7:0] tx_curr_byte = tx_data[(tx_byte_idx*8) +: 8]; // LSB-first byte order

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tx_shift     <= 10'h3FF; // idle high
            tx_bit_cnt   <= 4'd0;
            tx_busy_b    <= 1'b0;
            tx_byte_idx  <= {($clog2(TX_BYTES)+1){1'b0}};
            lb_pop_pulse <= 1'b0;
        end else begin
            lb_pop_pulse <= 1'b0;

            // Start a transfer
            if (!tx_busy_b) begin
                if (!LOOPBACK) begin
                    if (tx_valid) begin
                        tx_busy_b   <= 1'b1;
                        tx_byte_idx <= 0;
                        tx_shift    <= {1'b1, tx_curr_byte, 1'b0}; // {stop, data[7:0], start}
                        tx_bit_cnt  <= 0;
                        if (TX_BYTES > 1) tx_byte_idx <= 1;
                    end
                end else begin
                    // LOOPBACK: start when FIFO has data
                    if (!lb_empty) begin
                        tx_busy_b   <= 1'b1;
                        tx_shift    <= {1'b1, lb_dout, 1'b0};
                        tx_bit_cnt  <= 0;
                        lb_pop_pulse<= 1'b1; // consume the byte we just loaded
                    end
                end
            end else if (baud_tick) begin
                // Continue shifting (fills MSB with 1's, so idle/stop stay high)
                tx_shift   <= {1'b1, tx_shift[9:1]};
                tx_bit_cnt <= tx_bit_cnt + 1'b1;

                if (tx_bit_cnt == 4'd9) begin
                    // Finished a byte
                    if (!LOOPBACK) begin
                        if (tx_byte_idx < TX_BYTES) begin
                            tx_shift    <= {1'b1, tx_data[(tx_byte_idx*8) +: 8], 1'b0};
                            tx_bit_cnt  <= 0;
                            tx_byte_idx <= tx_byte_idx + 1'b1;
                        end else begin
                            tx_busy_b <= 1'b0;
                        end
                    end else begin
                        // LOOPBACK: immediately send next byte if available
                        if (!lb_empty) begin
                            tx_shift    <= {1'b1, lb_dout, 1'b0};
                            tx_bit_cnt  <= 0;
                            lb_pop_pulse<= 1'b1;
                        end else begin
                            tx_busy_b <= 1'b0;
                        end
                    end
                end
            end
        end
    end

    // =========================================================================
    // Assemble RX bytes into parallel word (still active in LOOPBACK)
    // =========================================================================
    localparam integer RX_BYTES = (RX_WIDTH + 7) / 8;
    reg [$clog2(RX_BYTES):0] rx_byte_idx;
    reg [RX_WIDTH-1:0]       rx_accum;
    reg [RX_WIDTH-1:0]       next_accum; // moved out for portability

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_byte_idx <= 0;
            rx_accum    <= {RX_WIDTH{1'b0}};
            rx_data     <= {RX_WIDTH{1'b0}};
            rx_valid    <= 1'b0;
        end else begin
            rx_valid <= 1'b0;
            if (rx_byte_ready) begin
                next_accum = rx_accum;
                next_accum[(rx_byte_idx*8) +: 8] = rx_byte; // LSB-first

                if (rx_byte_idx + 1 < RX_BYTES) begin
                    rx_accum     <= next_accum;
                    rx_byte_idx  <= rx_byte_idx + 1'b1;
                end else begin
                    rx_accum     <= {RX_WIDTH{1'b0}}; // optional clear
                    rx_data      <= next_accum;
                    rx_valid     <= 1'b1;
                    rx_byte_idx  <= 0;
                end
            end
        end
    end
endmodule
