//=======================================================
//  DE0_Nano Top
//  Includes PRBS test, Pattern test, UART transceiver,
//  and Loopback activation when BOTH switches are ON
//  (DE0-Nano slide switches are ACTIVE-LOW)
//=======================================================

module DE0_Nano(

    //////////// CLOCK //////////
    CLOCK_50,

    //////////// LED //////////
    LED,

    //////////// KEY //////////
    KEY,

    //////////// SW //////////
    SW,

    //////////// SDRAM //////////
    DRAM_ADDR,
    DRAM_BA,
    DRAM_CAS_N,
    DRAM_CKE,
    DRAM_CLK,
    DRAM_CS_N,
    DRAM_DQ,
    DRAM_DQM,
    DRAM_RAS_N,
    DRAM_WE_N,

    //////////// EPCS //////////
    EPCS_ASDO,
    EPCS_DATA0,
    EPCS_DCLK,
    EPCS_NCSO,

    //////////// Accelerometer and EEPROM //////////
    G_SENSOR_CS_N,
    G_SENSOR_INT,
    I2C_SCLK,
    I2C_SDAT,

    //////////// ADC //////////
    ADC_CS_N,
    ADC_SADDR,
    ADC_SCLK,
    ADC_SDAT,

    //////////// 2x13 GPIO Header //////////
    GPIO_2,
    GPIO_2_IN,

    //////////// GPIO_0, GPIO_0 connect to GPIO Default //////////
    GPIO_0_TX,
    GPIO_0_RX,
    GPIO_0,
    GPIO_0_IN,

    //////////// GPIO_1, GPIO_1 connect to GPIO Default //////////
    GPIO_1,
    GPIO_1_IN
);

//=======================================================
//  PORT declarations
//=======================================================
input              CLOCK_50;
output      [7:0]  LED;
input       [1:0]  KEY;
input       [3:0]  SW;

output     [12:0]  DRAM_ADDR;
output      [1:0]  DRAM_BA;
output             DRAM_CAS_N, DRAM_CKE, DRAM_CLK, DRAM_CS_N;
inout      [15:0]  DRAM_DQ;
output      [1:0]  DRAM_DQM;
output             DRAM_RAS_N, DRAM_WE_N;

output             EPCS_ASDO;
input              EPCS_DATA0;
output             EPCS_DCLK, EPCS_NCSO;

output             G_SENSOR_CS_N;
input              G_SENSOR_INT;
output             I2C_SCLK;
inout              I2C_SDAT;

output             ADC_CS_N, ADC_SADDR, ADC_SCLK;
input              ADC_SDAT;

inout      [12:0]  GPIO_2;
input       [2:0]  GPIO_2_IN;

input              GPIO_0_RX;
output             GPIO_0_TX;
inout      [33:2]  GPIO_0;
input       [1:0]  GPIO_0_IN;

inout      [33:0]  GPIO_1;
input       [1:0]  GPIO_1_IN;

//=======================================================
//  REG/WIRE declarations
//=======================================================
wire input_valid;
wire ready;

// Core-side ports
{% for input in inputs %}
wire [{{input.width - 1}}:0] {{ input.name }}_int;
{% endfor %}

{% for output in outputs %}
wire [{{output.width - 1}}:0] {{ output.name }}_int;
wire [{{output.width - 1}}:0] {{ output.name }}_out_int;
{% endfor %}

// ------------------------------------------------------
//  Per-signal byte-aligned UART segment widths
//  Each segment = ceil(width/8)*8 bits, with MSB padding.
// ------------------------------------------------------
{% for input in inputs %}
localparam {{input.name|upper}}_SEG_WIDTH = (({{input.width}} + 7) / 8) * 8;
{% endfor %}
{% for output in outputs %}
localparam {{output.name|upper}}_SEG_WIDTH = (({{output.width}} + 7) / 8) * 8;
{% endfor %}

// Total UART widths
localparam RX_WIDTH = {% if inputs|length == 0 %}0{% else %}{% for input in inputs %}{{input.name|upper}}_SEG_WIDTH{% if not loop.last %} + {% endif %}{% endfor %}{% endif %};
localparam TX_WIDTH = {% if outputs|length == 0 %}0{% else %}{% for output in outputs %}{{output.name|upper}}_SEG_WIDTH{% if not loop.last %} + {% endif %}{% endfor %}{% endif %};

wire [RX_WIDTH-1:0] rx_data_int;
wire [TX_WIDTH-1:0] tx_data_int;

// RX segment wires (one per input)
{% for input in inputs %}
wire [{{input.name|upper}}_SEG_WIDTH-1:0] {{ input.name }}_seg;
{% endfor %}

// UART TX mux paths
wire uart_tx_core;
wire prbs_tx;
wire prbs_active;
wire pat_tx;
wire pat_active;

// ---------------- Loopback wires ----------------------
wire       lb_tx;
wire [7:0] lb_last_rx_byte;
wire       lb_last_rx_strobe;
wire       lb_rx_ferr;
wire       lb_overflow;

//=======================================================
//  ACTIVE-LOW switches (DE0-Nano)
//  ON position pulls the signal low -> invert
//=======================================================
wire sw1_on = ~SW[1];     // PRBS switch (active-LOW)
wire sw2_on = ~SW[2];     // PATTERN switch (active-LOW)
wire lb_en  = sw1_on & sw2_on;   // Loopback when BOTH are ON

// Gate testers OFF whenever loopback is enabled
wire en_prbs = sw1_on & ~lb_en;
wire en_pat  = sw2_on & ~lb_en;

//=======================================================
//  Structural logic
//=======================================================
delayed_registers delayed_registers_inst (
    .clk        (CLOCK_50),
    .rst_n      (KEY[0]),
    .input_valid(input_valid),
{% for output in outputs %}
    .{{ output.name }}    ({{ output.name }}_int),
    .{{ output.name }}_out({{ output.name }}_out_int),
{% endfor %}
    .ready      (ready)
);

// ------------------------------------------------------
//  TX data packing: each output in its own byte-aligned
//  segment, LSB bits are the value, MSB bits are zero.
//  Segment order on UART (low -> high bits):
//    segment0 = outputs[0], segment1 = outputs[1], ...
// ------------------------------------------------------
assign tx_data_int = {
{% for output in outputs|reverse %}
    { ({{output.name|upper}}_SEG_WIDTH-{{output.width}}){1'b0} }, {{ output.name }}_out_int{% if not loop.last %},{% endif %}
{% endfor %}
};

// ------------------------------------------------------
//  RX data unpacking: each input has its own segment.
//  Segment order on UART (low -> high bits):
//    segment0 = inputs[0], segment1 = inputs[1], ...
// ------------------------------------------------------

// First split into per-input segments
assign {
{% for input in inputs|reverse %}
    {{ input.name }}_seg{% if not loop.last %},{% endif %}
{% endfor %}
} = rx_data_int;

// Then trim each segment's LSBs to the core input width
{% for input in inputs %}
assign {{ input.name }}_int = {{ input.name }}_seg[{{input.width - 1}}:0];
{% endfor %}

// ---------------- UART core transceiver ----------------
// Normal mode only — loopback disabled here
uart_transceiver #(
    .CLK_HZ   (50_000_000),
    .BAUD     (115200),
    .TX_WIDTH (TX_WIDTH),
    .RX_WIDTH (RX_WIDTH),
    .LOOPBACK (1'b0),
    .OSR      (16)
) uart_transceiver_inst(
    .clk      (CLOCK_50),
    .rst_n    (KEY[0]),
    .tx_data  (tx_data_int),
    .tx_valid (ready),
    .tx       (uart_tx_core),
    .rx       (GPIO_0_RX),
    .rx_data  (rx_data_int),
    .rx_valid (input_valid),
    .tx_busy  ()
);

// ---------------- Standalone LOOPBACK core -------------
uart_loopback #(
    .CLK_HZ        (50_000_000),
    .BAUD          (115200),
    .RX_ENA_STOPCHK(1'b1),
    .RX_MAJ3       (1'b1)
) u_uart_lb (
    .clk           (CLOCK_50),
    .rst_n         (KEY[0]),
    .tx            (lb_tx),
    .rx            (GPIO_0_RX),
    .last_rx_byte  (lb_last_rx_byte),
    .last_rx_strobe(lb_last_rx_strobe),
    .rx_ferr       (lb_rx_ferr),
    .lb_overflow   (lb_overflow)
);

// ---------------- PRBS7 TX tester ----------------------
uart_prbs7_tx_test #(
    .CLK_HZ     (50_000_000),
    .BAUD       (115200),
    .PERIOD_MS  (500),
    .BURST_BYTES(256),
    .PREAMBLE   (1'b1)
) u_prbs_tx (
    .clk    (CLOCK_50),
    .rst_n  (KEY[0]),
    .enable (en_prbs),        // gated by loopback
    .tx     (prbs_tx),
    .active (prbs_active)
);

// -------------- Fixed Pattern TX generator -------------
uart_fixed_pattern_tx #(
    .CLK_HZ    (50_000_000),
    .BAUD      (115200),
    .PERIOD_MS (200),
    .NUM_BYTES (32)
) u_pat_tx (
    .clk    (CLOCK_50),
    .rst_n  (KEY[0]),
    .enable (en_pat),         // gated by loopback
    .tx     (pat_tx),
    .active (pat_active)
);

// ---------------- TX output mux ------------------------
// Priority: loopback → pattern → PRBS → core
assign GPIO_0_TX = lb_en   ? lb_tx    :
                   en_pat  ? pat_tx   :
                   en_prbs ? prbs_tx  :
                              uart_tx_core;

// ---------------- LED status ---------------------------
// LED[0]=loopback selected, [1]=PRBS selected, [2]=PAT selected
// LED[3]=RX pin activity,  [4]=TX pin activity
assign LED[0]   = lb_en;
assign LED[1]   = en_prbs;
assign LED[2]   = en_pat;
assign LED[3]   = GPIO_0_RX;
assign LED[4]   = GPIO_0_TX;
assign LED[7:5] = 3'b000;

// ---------------- Main Core ----------------------------
{{ top_name }} {{ top_name }}_inst(
    //.clk(CLOCK_50),
{% for input in inputs %}
    .{{ input.name }}({{ input.name }}_int){% if not loop.last or outputs|length > 0 %},{% endif %}
{% endfor %}
{% for output in outputs %}
    .{{ output.name }}({{ output.name }}_int){% if not loop.last %},{% endif %}
{% endfor %}
);

endmodule
