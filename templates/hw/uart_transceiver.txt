// -----------------------------------------------------------------------------
// uart_transceiver.v  (LOOPBACK-capable, single-writer FIFO â€” no multi-drivers)
//  - 50 MHz default, 115200 baud
//  - RX: 16x oversampling (mid-bit sampling)
//  - Normal: packs tx_data -> UART; RX assembles bytes -> rx_data (pulses rx_valid)
//  - LOOPBACK=1: ignore tx_data/tx_valid; echo each received byte
// -----------------------------------------------------------------------------
module uart_transceiver #(
    parameter integer CLK_HZ    = 50000000,
    parameter integer BAUD      = 115200,
    parameter integer TX_WIDTH  = 32,
    parameter integer RX_WIDTH  = 32,
    parameter bit     LOOPBACK  = 1'b1,
    parameter integer OSR       = 16          // oversample rate (fixed at 16 in logic below)
)(
    input  wire                     clk,
    input  wire                     rst_n,

    // Parallel transmit (ignored when LOOPBACK=1)
    input  wire [TX_WIDTH-1:0]      tx_data,
    input  wire                     tx_valid,   // 1-clk strobe to start sending tx_data
    output wire                     tx_busy,

    // UART pins
    output wire                     tx,
    input  wire                     rx,

    // Parallel receive
    output reg  [RX_WIDTH-1:0]      rx_data,
    output reg                      rx_valid
);
    // =========================================================================
    // Baud / Oversample
    // =========================================================================
    localparam integer DIV_OS_TICK  = (CLK_HZ + (BAUD*OSR)/2) / (BAUD*OSR);
    localparam integer DIV_BAUD_TCK = (CLK_HZ + BAUD/2)       / BAUD;

    // 16x oversample tick
    reg [$clog2(DIV_OS_TICK)-1:0] os_div = 0;
    reg os_tick;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin os_div <= 0; os_tick <= 1'b0; end
        else begin
            os_tick <= 1'b0;
            if (os_div == DIV_OS_TICK-1) begin os_div <= 0; os_tick <= 1'b1; end
            else os_div <= os_div + 1'b1;
        end
    end

    // 1x baud tick
    reg [$clog2(DIV_BAUD_TCK)-1:0] bd_div = 0;
    reg baud_tick;
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin bd_div <= 0; baud_tick <= 1'b0; end
        else begin
            baud_tick <= 1'b0;
            if (bd_div == DIV_BAUD_TCK-1) begin bd_div <= 0; baud_tick <= 1'b1; end
            else bd_div <= bd_div + 1'b1;
        end
    end

    // =========================================================================
    // UART RX (8N1, 16x oversampling with mid-bit sample)
    // =========================================================================
    reg rx_s1, rx_s2;
    always @(posedge clk) begin
        rx_s1 <= rx;
        rx_s2 <= rx_s1; // double-sync
    end

    reg [3:0]  rx_os_cnt;     // 0..15 within bit
    reg [7:0]  rx_total_os;   // 0..159 over frame (10 bits * 16)
    reg [2:0]  rx_bit_idx;    // data bits 0..7
    reg [7:0]  rx_shift;
    reg        rx_busy_b;
    reg        rx_byte_ready;
    reg [7:0]  rx_byte;
    reg        rx_stop_ok;    // simple stop-bit check (optional)

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_os_cnt     <= 0;
            rx_total_os   <= 0;
            rx_bit_idx    <= 0;
            rx_shift      <= 8'h00;
            rx_busy_b     <= 1'b0;
            rx_byte_ready <= 1'b0;
            rx_byte       <= 8'h00;
            rx_stop_ok    <= 1'b0;
        end else begin
            rx_byte_ready <= 1'b0;

            if (!rx_busy_b) begin
                // look for start (line low) on an oversample tick
                if (os_tick && (rx_s2 == 1'b0)) begin
                    rx_busy_b   <= 1'b1;
                    rx_os_cnt   <= 4'd0;
                    rx_total_os <= 8'd0;
                    rx_bit_idx  <= 3'd0;
                    rx_shift    <= 8'h00;
                    rx_stop_ok  <= 1'b0;
                end
            end else if (os_tick) begin
                // advance oversample counters
                rx_os_cnt   <= rx_os_cnt + 4'd1;     // wraps naturally 15->0
                rx_total_os <= rx_total_os + 8'd1;

                // mid-bit sample points: 7, 23, 39, ..., 7 + n*16
                // start bit is at total_os in [0..15], ignore sample at 7
                if (rx_os_cnt == 4'd7) begin
                    if (rx_total_os >= 8'd16 && rx_total_os < 8'd144) begin
                        // data bits window (8 bits @ 16 ticks each)
                        // LSB-first: shift-left and append sampled bit into bit0
                        rx_shift   <= {rx_shift[6:0], rx_s2};
                        rx_bit_idx <= rx_bit_idx + 3'd1;
                    end else if (rx_total_os == 8'd151) begin
                        // mid stop-bit sample (near end)
                        rx_stop_ok <= rx_s2; // expect high
                    end
                end

                // end of 10-bit frame (start + 8 data + stop)
                if (rx_total_os == (OSR*10 - 1)) begin
                    rx_busy_b     <= 1'b0;
                    rx_byte       <= rx_shift;
                    rx_byte_ready <= 1'b1; // you could gate with rx_stop_ok if desired
                end
            end
        end
    end

    // =========================================================================
    // Tiny 4-byte FIFO for LOOPBACK (single writer block!)
    // =========================================================================
    reg [7:0] lb_mem [0:3];
    reg [1:0] lb_rptr, lb_wptr;
    reg [2:0] lb_count; // 0..4

    wire lb_full  = (lb_count == 3'd4);
    wire lb_empty = (lb_count == 3'd0);
    wire [7:0] lb_dout = lb_mem[lb_rptr];

    // Push/pop pulses (generated by RX/TX logic)
    wire lb_push_pulse = LOOPBACK && rx_byte_ready && !lb_full;
    reg  lb_pop_pulse;  // set by TX state machine when it consumes a byte

    // SINGLE always block updates pointers & count
    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            lb_rptr <= 2'd0; lb_wptr <= 2'd0; lb_count <= 3'd0;
        end else if (LOOPBACK) begin
            // push
            if (lb_push_pulse) begin
                lb_mem[lb_wptr] <= rx_byte;
                lb_wptr <= lb_wptr + 2'd1;
            end
            // pop
            if (lb_pop_pulse && !lb_empty) begin
                lb_rptr <= lb_rptr + 2'd1;
            end
            // count update (push/pop same cycle allowed)
            case ({lb_push_pulse, (lb_pop_pulse && !lb_empty)})
                2'b10: lb_count <= lb_count + 3'd1;
                2'b01: lb_count <= lb_count - 3'd1;
                default: /* no change */ ;
            endcase
        end else begin
            // keep reset when not used
            lb_rptr <= 2'd0; lb_wptr <= 2'd0; lb_count <= 3'd0;
        end
    end

    // =========================================================================
    // UART TX (8N1)
    // =========================================================================
    reg [9:0] tx_shift;
    reg [3:0] tx_bit_cnt;      // 0..9
    reg       tx_busy_b;

    assign tx      = tx_shift[0];
    assign tx_busy = tx_busy_b;

    localparam integer TX_BYTES = (TX_WIDTH + 7) / 8;
    reg [$clog2(TX_BYTES):0] tx_byte_idx;
    wire [7:0] tx_curr_byte = tx_data[(tx_byte_idx*8) +: 8]; // LSB-first byte order

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            tx_shift     <= 10'h3FF; // idle high
            tx_bit_cnt   <= 4'd0;
            tx_busy_b    <= 1'b0;
            tx_byte_idx  <= {($clog2(TX_BYTES)+1){1'b0}};
            lb_pop_pulse <= 1'b0;
        end else begin
            lb_pop_pulse <= 1'b0;

            // Start a transfer
            if (!tx_busy_b) begin
                if (!LOOPBACK) begin
                    if (tx_valid) begin
                        tx_busy_b   <= 1'b1;
                        tx_byte_idx <= 0;
                        tx_shift    <= {1'b1, tx_curr_byte, 1'b0}; // {stop, data[7:0], start}
                        tx_bit_cnt  <= 0;
                        if (TX_BYTES > 1) tx_byte_idx <= 1;
                    end
                end else begin
                    // LOOPBACK: start when FIFO has data
                    if (!lb_empty) begin
                        tx_busy_b   <= 1'b1;
                        tx_shift    <= {1'b1, lb_dout, 1'b0};
                        tx_bit_cnt  <= 0;
                        lb_pop_pulse<= 1'b1; // consume the byte we just loaded
                    end
                end
            end else if (baud_tick) begin
                // Continue shifting (fills MSB with 1's, so idle/stop stay high)
                tx_shift   <= {1'b1, tx_shift[9:1]};
                tx_bit_cnt <= tx_bit_cnt + 1'b1;

                if (tx_bit_cnt == 4'd9) begin
                    // Finished a byte
                    if (!LOOPBACK) begin
                        if (tx_byte_idx < TX_BYTES) begin
                            tx_shift    <= {1'b1, tx_data[(tx_byte_idx*8) +: 8], 1'b0};
                            tx_bit_cnt  <= 0;
                            tx_byte_idx <= tx_byte_idx + 1'b1;
                        end else begin
                            tx_busy_b <= 1'b0;
                        end
                    end else begin
                        // LOOPBACK: immediately send next byte if available
                        if (!lb_empty) begin
                            tx_shift    <= {1'b1, lb_dout, 1'b0};
                            tx_bit_cnt  <= 0;
                            lb_pop_pulse<= 1'b1;
                        end else begin
                            tx_busy_b <= 1'b0;
                        end
                    end
                end
            end
        end
    end

    // =========================================================================
    // Assemble RX bytes into parallel word (still active in LOOPBACK)
    // =========================================================================
    localparam integer RX_BYTES = (RX_WIDTH + 7) / 8;
    reg [$clog2(RX_BYTES):0] rx_byte_idx;
    reg [RX_WIDTH-1:0]       rx_accum;

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_byte_idx <= 0;
            rx_accum    <= {RX_WIDTH{1'b0}};
            rx_data     <= {RX_WIDTH{1'b0}};
            rx_valid    <= 1'b0;
        end else begin
            rx_valid <= 1'b0;
            if (rx_byte_ready) begin
                // build next_accum to avoid NB-assign race on the last byte
                reg [RX_WIDTH-1:0] next_accum;
                next_accum = rx_accum;
                next_accum[(rx_byte_idx*8) +: 8] = rx_byte; // LSB-first

                if (rx_byte_idx + 1 < RX_BYTES) begin
                    rx_accum     <= next_accum;
                    rx_byte_idx  <= rx_byte_idx + 1'b1;
                end else begin
                    rx_accum     <= {RX_WIDTH{1'b0}}; // optional clear
                    rx_data      <= next_accum;
                    rx_valid     <= 1'b1;
                    rx_byte_idx  <= 0;
                end
            end
        end
    end
endmodule
