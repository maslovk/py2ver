// uart_rx_8n1.sv — 8N1 RX with 16× oversampling and optional maj3 mid-bit
module uart_rx_8n1 #(
    parameter bit RX_ENA_STOPCHK = 1'b1,
    parameter bit RX_MAJ3        = 1'b1
)(
    input  logic clk,
    input  logic rst_n,
    input  logic os_tick,           // 16× oversample tick
    input  logic rx,                // async pin

    output logic [7:0] rx_byte,     // received byte
    output logic       rx_byte_ready, // 1-clk pulse
    output logic       rx_ferr        // framing error pulse (bad stop)
);
    // double-sync
    logic rx_s1, rx_s2;
    always_ff @(posedge clk) begin
        rx_s1 <= rx;
        rx_s2 <= rx_s1;
    end

    logic [3:0] rx_os_cnt;     // 0..15
    logic [7:0] rx_total_os;   // 0..159 over frame (10*16)
    logic [2:0] rx_bit_idx;    // 0..7
    logic [7:0] rx_shift;
    logic       rx_busy_b;
    logic       rx_stop_ok;

    // majority-of-3 around mid-bit
    logic [1:0] maj_accum;     // 0..3
    wire        maj_bit = (maj_accum >= 2);

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            rx_os_cnt      <= '0;
            rx_total_os    <= '0;
            rx_bit_idx     <= '0;
            rx_shift       <= 8'h00;
            rx_busy_b      <= 1'b0;
            rx_byte_ready  <= 1'b0;
            rx_byte        <= 8'h00;
            rx_stop_ok     <= 1'b0;
            rx_ferr        <= 1'b0;
            maj_accum      <= '0;
        end else begin
            rx_byte_ready <= 1'b0;
            rx_ferr       <= 1'b0;

            if (!rx_busy_b) begin
                if (os_tick && (rx_s2 == 1'b0)) begin
                    rx_busy_b   <= 1'b1;
                    rx_os_cnt   <= '0;
                    rx_total_os <= '0;
                    rx_bit_idx  <= '0;
                    rx_shift    <= 8'h00;
                    rx_stop_ok  <= 1'b0;
                    maj_accum   <= '0;
                end
            end else if (os_tick) begin
                rx_os_cnt   <= rx_os_cnt + 4'd1;
                rx_total_os <= rx_total_os + 8'd1;

                if (RX_MAJ3) begin
                    if (rx_os_cnt == 4'd6)      maj_accum <= {1'b0, rx_s2};
                    else if (rx_os_cnt == 4'd7) maj_accum <= maj_accum + {1'b0, rx_s2};
                    else if (rx_os_cnt == 4'd8) maj_accum <= maj_accum + {1'b0, rx_s2};
                end

                if (!RX_MAJ3) begin
                    if (rx_os_cnt == 4'd7) begin
                        if (rx_total_os >= 8'd16 && rx_total_os < 8'd144) begin
                            rx_shift[rx_bit_idx] <= rx_s2;
                            rx_bit_idx           <= rx_bit_idx + 3'd1;
                        end else if (rx_total_os == 8'd151) begin
                            rx_stop_ok <= rx_s2;
                        end
                    end
                end else begin
                    if (rx_os_cnt == 4'd8) begin
                        if (rx_total_os >= 8'd17 && rx_total_os < 8'd145) begin
                            rx_shift[rx_bit_idx] <= maj_bit;
                            rx_bit_idx           <= rx_bit_idx + 3'd1;
                        end else if (rx_total_os == 8'd152) begin
                            rx_stop_ok <= maj_bit;
                        end
                    end
                end

                if (rx_total_os == (16*10 - 1)) begin
                    rx_busy_b <= 1'b0;
                    if (!RX_ENA_STOPCHK || rx_stop_ok) begin
                        rx_byte       <= rx_shift;
                        rx_byte_ready <= 1'b1;
                    end else begin
                        rx_ferr       <= 1'b1;
                    end
                end
            end
        end
    end
endmodule
