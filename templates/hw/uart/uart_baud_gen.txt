// uart_baud_gen.sv — 16× oversample + 1× baud tick (phase-aligned)
module uart_baud_gen #(
    parameter int CLK_HZ = 50_000_000,
    parameter int BAUD   = 115_200,
    parameter int OSR    = 16
)(
    input  logic clk,
    input  logic rst_n,
    output logic os_tick,    // 16× oversample tick
    output logic baud_tick   // 1× baud tick (aligned to os_tick)
);
    // Fixed-OSR variant
    // synthesis translate_off
    initial if (OSR != 16) $error("uart_baud_gen: OSR must be 16 in this variant.");
    // synthesis translate_on

    // ---------------- Fractional divider (Bresenham) ----------------
    // Each clk: acc += INC; if acc >= MOD -> os_tick=1 and acc -= MOD.
    // Average tick rate = (INC / MOD) * fclk = (BAUD*OSR) exactly (on average).
    localparam int unsigned INC = BAUD * OSR;   // e.g. 115200*16 = 1_843_200
    localparam int unsigned MOD = CLK_HZ;       // e.g. 50_000_000

    // State
    logic [31:0] acc;            // accumulator
    logic [32:0] sum;            // adder temp (declared outside always for Quartus)
    logic [3:0]  osr_cnt = '0;   // 0..15 for OSR=16

    // Generate oversample tick (os_tick) using fractional divider
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            acc     <= '0;
            os_tick <= 1'b0;
        end else begin
            os_tick <= 1'b0;
            sum = acc + INC;               // 33-bit add
            if (sum >= MOD) begin
                acc     <= sum - MOD;      // subtract modulus
                os_tick <= 1'b1;           // 1-cycle oversample tick
            end else begin
                acc <= sum[31:0];
            end
        end
    end

    // Divide os_tick by OSR to make aligned baud_tick
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            osr_cnt   <= '0;
            baud_tick <= 1'b0;
        end else begin
            baud_tick <= 1'b0;
            if (os_tick) begin
                if (osr_cnt == OSR-1) begin
                    osr_cnt   <= '0;
                    baud_tick <= 1'b1;
                end else begin
                    osr_cnt <= osr_cnt + 4'd1;
                end
            end
        end
    end
endmodule
